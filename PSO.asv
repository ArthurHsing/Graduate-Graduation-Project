function [] = PSO(N,T,Lb,Ub,dim,fobj,w,c1,c2,vlimit)
    Sol = initialization(N, dim, Ub, Lb);%初始种群的位置
    v = rand(N, dim);                  % 初始种群的速度
    Sbest = zeros(1, dim);                % 种群的历史最佳位置
    fmin = zeros(N, 1);               % 每个个体的历史最佳适应度
    fitnessBest = Inf;                      % 种群历史最佳适应度
    %% 群体更新
    iter = 1;
    Convergence_curve = zeros(1, T);          % 记录器
    for i = 1:N
        [fitnessTemp, fitnessRecord] = fobj(Sol(i,:));
        Fitness(i)= fitnessTemp;
        FR(i) = fitnessRecord;
    end
    
    % Find the current best_pos
    [fmin,I]=min(Fitness);
    best_pos=Sol(I,:);
    FRBest = FR(I);
    S=Sol; 
    
    while iter <= T
        for i = 1:N      
        [fnew, ] = fobj(Sol(i, :)) ; % 个体当前适应度   
        if fnew < fmin(i) 
            fmin(i) = fnew;     % 更新个体历史最佳适应度
            S(i,:) = Sol(i,:);   % 更新个体历史最佳位置
            FR(i) = 
        end 
        end
        [fitnessBestPerIter, index] = min(fmin);
        if fitnessBestPerIter < fitnessBest % 更新群体历史最佳适应度
            fitnessBest = fitnessBestPerIter;
            Sbest = S(index, :);
        end
        v = v * w + c1 * rand * (xm - Sol) + c2 * rand * (repmat(Sbest, N, 1) - Sol);% 速度更新
        % 边界速度处理
        v(v > vlimit(2)) = vlimit(2);
        v(v < vlimit(1)) = vlimit(1);
        Sol = Sol + v;% 位置更新
        % 边界位置处理
        Sol(Sol > limit(2)) = limit(2);
        Sol(Sol < limit(1)) = limit(1);
        Convergence_curve(iter) = fitnessBest;%最大值记录
        iter = iter+1;
    end
    % figure(1);plot(record);title('收敛过程')

    figure,
    semilogy(Convergence_curve,'r')
    %     semilogy(CNVG_Subtract_STD,'r') %要减去标准差的图
    xlim([0 T]);
    title('Convergence curve')
    xlabel('Iteration');
    ylabel('Best fitness obtained so far');
    legend('PSO')
end

% This function randomly initializes the position of agents in the search space.
function [X]=initialization(N,dim,up,down)

    if size(up,1)==1
        X=rand(N,dim).*(up-down)+down;
    end
    if size(up,1)>1
        for i=1:dim
            high=up(i);low=down(i);
            X(:,i)=rand(1,N).*(high-low)+low;
        end
    end
end
